#!/usr/bin/env python3
"""
PMTA Configuration Generator
Reads accounts.json and generates complete PMTA configuration
"""

import json
import sys
import argparse
from pathlib import Path
from datetime import datetime
import subprocess


class PMTAConfigGenerator:
    """Generates PMTA configuration from accounts.json"""

    def __init__(self, accounts_file: str, output_file: str, proxy_host: str = '127.0.0.1',
                 proxy_port: int = 2525, max_smtp_out: int = 10, max_connections: int = 5):
        self.accounts_file = accounts_file
        self.output_file = output_file
        self.proxy_host = proxy_host
        self.proxy_port = proxy_port
        self.max_smtp_out = max_smtp_out
        self.max_connections = max_connections
        self.accounts = []

    def load_accounts(self) -> bool:
        """Load accounts from JSON file"""
        try:
            with open(self.accounts_file, 'r') as f:
                data = json.load(f)
            self.accounts = data.get('accounts', [])
            print(f"[OK] Loaded {len(self.accounts)} accounts from {self.accounts_file}")
            return True
        except FileNotFoundError:
            print(f"✗ Error: File not found: {self.accounts_file}", file=sys.stderr)
            return False
        except json.JSONDecodeError as e:
            print(f"✗ Error: Invalid JSON: {e}", file=sys.stderr)
            return False
        except Exception as e:
            print(f"✗ Error: {e}", file=sys.stderr)
            return False

    def generate_header(self) -> str:
        """Generate configuration header"""
        return f"""# PowerMTA v6 Configuration with XOAUTH2 Proxy
# Auto-generated by generate_pmta_config.py
# Generated: {datetime.now().isoformat()}
# Accounts: {len(self.accounts)}
# Proxy: {self.proxy_host}:{self.proxy_port}

job-class default
max-connections 100
max-connections-per-source 10
binding-rate-limit 100000
max-multithreading-degree 8


# =====================================================================
# LOGGING CONFIGURATION
# =====================================================================
log-file /var/log/pmta/pmta.log size=100M rotation=20

<bounce-log pmta-bounces>
  filename /var/log/pmta/bounces.log
  record-all-bounces yes
  output-format detailed
</bounce-log>

<bounce-log pmta-failures>
  filename /var/log/pmta/failures.log
  output-format detailed
</bounce-log>

<smtp-source pmta-smtp>
  port 25
  max-connections 1000
  max-connections-per-source 100
  log-connections yes
  max-message-size 52428800
</smtp-source>

<smtp-source pmta-smtp-auth>
  port 587
  max-connections 500
  max-connections-per-source 50
  allow-auth yes
  log-connections yes
  max-message-size 52428800
</smtp-source>

"""

    def generate_virtual_mtas(self) -> str:
        """Generate virtual-mta blocks"""
        config = "\n# =====================================================================\n"
        config += "# VIRTUAL-MTA CONFIGURATION ({} accounts)\n".format(len(self.accounts))
        config += "# =====================================================================\n\n"

        for account in self.accounts:
            vmta_name = account.get('vmta_name')
            ip_address = account.get('ip_address')
            config += f"""<virtual-mta {vmta_name}>
  smtp-source-host {ip_address}
</virtual-mta>

"""

        return config

    def generate_domain_config(self) -> str:
        """Generate domain configuration"""
        return """
# =====================================================================
# DOMAIN CONFIGURATION
# =====================================================================

<domain gmail.com>
  bounce-log pmta-bounces
  failure-log pmta-failures
  use-dkim yes
  dkim-signer-domain gmail.com
  dkim-private-key-file /etc/pmta/dkim/gmail.key
</domain>

<domain default>
  bounce-log pmta-bounces
  failure-log pmta-failures
  max-delivery-attempts 10
  attempt-interval 15m
</domain>

"""

    def generate_routes(self) -> str:
        """Generate route blocks"""
        config = "\n# =====================================================================\n"
        config += "# ROUTES TO XOAUTH2 PROXY ({}:{})\n".format(self.proxy_host, self.proxy_port)
        config += "# =====================================================================\n\n"

        for i, account in enumerate(self.accounts, 1):
            vmta_name = account.get('vmta_name')
            email = account.get('email')
            route_name = f"{account.get('account_id')}-gmail"

            config += f"""<route {route_name}>
  virtual-mta {vmta_name}
  domain gmail.com
  smtp-host {self.proxy_host} port={self.proxy_port}
  auth-username {email}
  auth-password placeholder
  max-smtp-out {self.max_smtp_out}
  max-smtp-connections {self.max_connections}
</route>

"""

        return config

    def generate_footer(self) -> str:
        """Generate configuration footer"""
        return """
# =====================================================================
# DEFAULT ROUTE (non-gmail domains)
# =====================================================================

<route default>
  max-smtp-out 100
  max-smtp-connections 20
</route>


# =====================================================================
# PERFORMANCE TUNING
# =====================================================================
dns-cache-ttl 300
dns-parallel-queries 4
queue-checkpoint-interval 60m
queue-dump-directory /var/spool/pmta/queue

<performance-settings>
  queue-cache-memory 100
  max-workers 32
</performance-settings>


# =====================================================================
# SECURITY & POLICY
# =====================================================================
<policy auth-policy>
  relay-allowed
</policy>

<policy default-policy>
  relay-allowed
</policy>

# End of auto-generated PMTA Configuration
"""

    def generate(self) -> bool:
        """Generate complete PMTA configuration"""
        try:
            config = self.generate_header()
            config += self.generate_virtual_mtas()
            config += self.generate_domain_config()
            config += self.generate_routes()
            config += self.generate_footer()

            with open(self.output_file, 'w') as f:
                f.write(config)

            print(f"[OK] Generated PMTA config: {self.output_file}")
            print(f"  - Virtual-MTAs: {len(self.accounts)}")
            print(f"  - Routes: {len(self.accounts)}")
            print(f"  - Proxy: {self.proxy_host}:{self.proxy_port}")
            return True

        except Exception as e:
            print(f"✗ Error generating config: {e}", file=sys.stderr)
            return False

    def validate_config(self) -> bool:
        """Validate generated config"""
        try:
            with open(self.output_file, 'r') as f:
                content = f.read()

            errors = []

            # Check for virtual-mta blocks
            vmta_count = content.count('<virtual-mta')
            if vmta_count != len(self.accounts):
                errors.append(f"Virtual-MTA count mismatch: found {vmta_count}, expected {len(self.accounts)}")

            # Check for route blocks
            route_count = content.count('<route')
            if route_count < len(self.accounts):
                errors.append(f"Route count mismatch: found {route_count}, expected at least {len(self.accounts)}")

            # Check for required directives
            if 'log-file' not in content:
                errors.append("Missing log-file directive")
            if '<bounce-log' not in content:
                errors.append("Missing bounce-log configuration")
            if '<domain gmail.com>' not in content:
                errors.append("Missing gmail.com domain configuration")

            if errors:
                print("✗ Validation errors:")
                for error in errors:
                    print(f"  - {error}")
                return False

            print(f"[OK] Configuration validation passed")
            return True

        except Exception as e:
            print(f"✗ Validation error: {e}", file=sys.stderr)
            return False

    def reload_pmta(self) -> bool:
        """Reload PMTA with new configuration"""
        try:
            print("Attempting to reload PMTA...")
            # Check if pmta-config is available
            result = subprocess.run(['pmta', 'show', 'config'], capture_output=True, text=True, timeout=10)

            if result.returncode != 0:
                print("✗ PMTA is not running or not found", file=sys.stderr)
                print("  Run: /etc/init.d/pmta reload")
                return False

            # Reload configuration
            result = subprocess.run(['pmta', 'reload'], capture_output=True, text=True, timeout=10)

            if result.returncode == 0:
                print("[OK] PMTA reloaded successfully")
                return True
            else:
                print(f"✗ PMTA reload failed: {result.stderr}", file=sys.stderr)
                return False

        except FileNotFoundError:
            print("✗ PMTA command not found", file=sys.stderr)
            print("  Run: /etc/init.d/pmta reload")
            return False
        except subprocess.TimeoutExpired:
            print("✗ PMTA command timed out", file=sys.stderr)
            return False
        except Exception as e:
            print(f"✗ Error reloading PMTA: {e}", file=sys.stderr)
            return False


def main():
    """Main entry point"""
    parser = argparse.ArgumentParser(
        description='Generate PMTA configuration from accounts.json'
    )
    parser.add_argument(
        'accounts_file',
        help='Path to accounts.json'
    )
    parser.add_argument(
        '-o', '--output',
        default='pmta_generated.cfg',
        help='Output config file (default: pmta_generated.cfg)'
    )
    parser.add_argument(
        '--proxy-host',
        default='127.0.0.1',
        help='XOAUTH2 proxy host (default: 127.0.0.1)'
    )
    parser.add_argument(
        '--proxy-port',
        type=int,
        default=2525,
        help='XOAUTH2 proxy port (default: 2525)'
    )
    parser.add_argument(
        '--max-smtp-out',
        type=int,
        default=10,
        help='Max SMTP out per route (default: 10)'
    )
    parser.add_argument(
        '--max-connections',
        type=int,
        default=5,
        help='Max SMTP connections per route (default: 5)'
    )
    parser.add_argument(
        '--reload',
        action='store_true',
        help='Reload PMTA after generating config'
    )
    parser.add_argument(
        '--validate-only',
        action='store_true',
        help='Only validate configuration'
    )

    args = parser.parse_args()

    # Verify input file exists
    if not Path(args.accounts_file).exists():
        print(f"✗ Error: File not found: {args.accounts_file}", file=sys.stderr)
        sys.exit(1)

    generator = PMTAConfigGenerator(
        accounts_file=args.accounts_file,
        output_file=args.output,
        proxy_host=args.proxy_host,
        proxy_port=args.proxy_port,
        max_smtp_out=args.max_smtp_out,
        max_connections=args.max_connections
    )

    # Load accounts
    if not generator.load_accounts():
        sys.exit(1)

    # Generate configuration
    if not args.validate_only:
        if not generator.generate():
            sys.exit(1)

    # Validate configuration
    if not generator.validate_config():
        sys.exit(1)

    # Optionally reload PMTA
    if args.reload:
        if not generator.reload_pmta():
            print("\nTo reload PMTA manually, run:")
            print(f"  sudo /etc/init.d/pmta stop")
            print(f"  sudo cp {args.output} /etc/pmta/pmta.cfg")
            print(f"  sudo /etc/init.d/pmta start")

    print("\nConfiguration generation complete!")
    print(f"Output: {args.output}")


if __name__ == '__main__':
    main()
